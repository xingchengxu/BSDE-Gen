# -*- coding: utf-8 -*-
# Author: Xingcheng Xu
"""
# BSDE-Gen Model
"""

"""
## Model Class
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import random


# Setting reproducibility
def setup_seed(seed):
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    np.random.seed(seed)
    random.seed(seed)
    torch.backends.cudnn.deterministic = True


# 设置随机数种子
setup_seed(0)


class FBSDEGen(nn.Module):
    def __init__(self, b, sigma, f, dim_x, dim_w, dim_y=784, dim_h1=1000, dim_h2=600, dim_h3=1000, T=1.0, N=200, device=None):
        super(FBSDEGen, self).__init__()

        self.b = b
        self.sigma = sigma
        self.f = f
        self.T = T
        self.N = N
        self.dim_x = dim_x
        self.dim_y = dim_y
        self.dim_w = dim_w

        self.y0_nn = nn.Sequential(
            nn.Linear(dim_x, dim_h1),
            # nn.Dropout(p=0.2),
            nn.GELU(),
            nn.Linear(dim_h1, dim_h2),
            nn.Dropout(p=0.2),
            nn.GELU(),
            nn.Linear(dim_h2, dim_h3),
            nn.Dropout(p=0.2),
            nn.GELU(),
            nn.Linear(dim_h3, dim_y)
        )

        self.z_nn = nn.Sequential(
            nn.Linear(dim_x + 1, dim_h1),
            # nn.Dropout(p=0.2),
            nn.GELU(),
            nn.Linear(dim_h1, dim_h2),
            nn.Dropout(p=0.2),
            nn.GELU(),
            nn.Linear(dim_h2, dim_h3 * dim_w // 4),
            nn.Dropout(p=0.2),
            nn.GELU(),
            nn.Linear(dim_h3 * dim_w // 4, dim_y * dim_w)
        )

    def forward(self, input_samples):
        batch_size = input_samples.size()[0]

        delta_t = self.T / self.N

        y_0 = self.y0_nn(input_samples).to(device)

        x = input_samples + torch.zeros(batch_size, self.dim_x, device=device)
        y = y_0 + torch.zeros(batch_size, self.dim_y, device=device)

        for i in range(self.N):
            z_input = torch.cat((x, torch.ones(batch_size, 1, device=device) * delta_t * i), 1)
            z = self.z_nn(z_input).reshape(-1, self.dim_y, self.dim_w).to(device)

            dw = torch.randn(batch_size, self.dim_w, 1, device=device) * np.sqrt(delta_t)
            x = x + self.b(delta_t * i, x) * delta_t + torch.matmul(self.sigma(delta_t * i, x), dw).reshape(-1, self.dim_x)
            y = y - self.f(delta_t * i, x, y, z) * delta_t + torch.matmul(z, dw).reshape(-1, self.dim_y)
        return x, y


# ********************************************* #
"""
## Model Inference
"""
# %matplotlib inline

import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np


device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"device={device}")

# hyperparameters
T, N = 1.0, 200
dim_x, dim_y, dim_w = 32, 784, 32
dim_h1, dim_h2, dim_h3 = 64, 32, 64  # 1000, 600, 1000

model_store_path="bsde_mlp_ddp.pt"  # "bsde_mlp_single_0.pt"
image_store_path = "bsde_mlp_gen.png"
image_store_path_norm = "bsde_mlp_gen_norm.png"


# X: Ornstein–Uhlenbeck (OU) process
def b(t, x):
    batch_size = x.size()[0]
    return -x.reshape(batch_size, dim_x)


def sigma(t, x):
    batch_size = x.size()[0]
    idmat = torch.eye(dim_x, dim_w, device=device)*np.sqrt(2)
    return idmat.repeat(batch_size, 1, 1)


# # X: Brownian Motion
# def b(t, x):
#     batch_size = x.size()[0]
#     return torch.zeros(batch_size, dim_x, device=device)
#
#
# def sigma(t, x):
#     batch_size = x.size()[0]
#     idmat = torch.eye(dim_x, dim_w, device=device)
#     return idmat.repeat(batch_size, 1, 1)


# def f(t, x, y, z):
#     # generator, it can be choosen!
#     batch_size = x.size()[0]
#     return -torch.abs(y).reshape(batch_size, dim_y).to(device)


def f(t, x, y, z):
    # generator, it can be choosen!
    batch_size = x.size()[0]
    z_term = torch.sum(torch.abs(z), 2).reshape(batch_size, dim_y).to(device)
    return (-y+z_term).reshape(batch_size, dim_y).to(device)


# def f(t, x, y, z):
#     # generator, it can be choosen! Interaction of components, linear approximation.
#     import torch
#     A = torch.load('tensor_A.pt').to(device)
#     batch_size = x.size()[0]
#     B = (-y).reshape(batch_size, dim_y, 1).to(device)
#     return torch.matmul(0.01*A, B).reshape(batch_size, dim_y).to(device)


model = FBSDEGen(b, sigma, f, dim_x, dim_w, dim_y, dim_h1, dim_h2, dim_h3, T, N, device=device)
model = model.to(device)


def model_inference(input_noise, img_output=False, model_store_path=None):
    model.load_state_dict(torch.load(model_store_path))
    model.eval()

    _, y_output = model(input_noise)

    if img_output == True:
        plt.gray()

        print("Images generated by FBSDE-Gen Model")
        plt.imshow(y_output.detach().squeeze().cpu().reshape(28, 28))
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
        plt.show()
        # plt.savefig("bsde_gen_mnist.png")
        plt.close()

    return y_output


print("Images generated by BSDE-Gen Model")

n_row = 10
n_col = 12
y_trans = torch.zeros(n_row*n_col, dim_y, device=device)
for row in range(n_row):
    for col in range(n_col):
        ax = plt.subplot(n_row, n_col, row * n_col + col + 1)

        input_noise = torch.randn(1, dim_x, device=device)
        y_output = model_inference(input_noise, model_store_path=model_store_path)
        plt.imshow(y_output.detach().squeeze().cpu().reshape(28, 28),
                   cmap="gray", interpolation="gaussian")
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)

        # normalization --> [0,1]
        y_temp = y_output.clone()
        y_temp -= torch.min(y_temp)
        y_temp /= torch.max(y_temp)
        y_trans[row * n_col + col, :] = y_temp.clone()
plt.show()
plt.savefig(image_store_path)
plt.close()


for row in range(n_row):
    for col in range(n_col):
        ax = plt.subplot(n_row, n_col, row * n_col + col + 1)
        plt.imshow(y_trans[row * n_col + col].detach().squeeze().cpu().reshape(28, 28),
                   cmap="gray", clim=(0.25, 1.0), interpolation="gaussian")
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
plt.show()
plt.savefig(image_store_path_norm)
plt.close()


"""**END**"""
